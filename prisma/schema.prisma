// prisma/schema.prisma

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

// =====================================================
// ENUMS
// =====================================================

enum UserRole {
  ADMIN
  SUPER_ADMIN
}

enum PersonnelRole {
  RESPONDER
  MEDIC
  FIREFIGHTER
  POLICE
  COORDINATOR
}

enum PersonnelStatus {
  AVAILABLE
  RESPONDING        // NEW: En route to incident
  ON_SCENE          // NEW: At incident location
  ON_DUTY
  OFF_DUTY
  ON_BREAK
  INACTIVE
  SUSPENDED
}

enum IncidentStatus {
  PENDING_VERIFICATION
  VERIFIED          // NEW: Admin verified, waiting for response
  REPORTED
  ACKNOWLEDGED
  DISPATCHED
  IN_PROGRESS       // Legacy - use RESPONDING instead
  RESPONDING        // NEW: Personnel en route
  ARRIVED           // NEW: Personnel on scene
  PENDING_RESOLVE   // NEW: Personnel submitted resolution, waiting admin confirmation
  RESOLVED
  CLOSED
  CANCELLED
  SPAM
}

enum IncidentPriority {
  LOW
  MEDIUM
  HIGH
  CRITICAL
}

enum IncidentType {
  FIRE
  MEDICAL
  ACCIDENT
  CRIME
  FLOOD
  NATURAL_DISASTER
  OTHER
}

enum EmergencyContactType {
  EMERGENCY
  BARANGAY_HALL
  POLICE
  FIRE
  MEDICAL
  OTHER
}

// =====================================================
// USER MANAGEMENT
// =====================================================

model User {
  id        String   @id @default(cuid())
  email     String   @unique
  password  String
  firstName String
  lastName  String
  phone     String?
  role      UserRole @default(ADMIN)
  isActive  Boolean  @default(true)
  
  // Account security
  failedLoginAttempts Int      @default(0)
  lastFailedLogin     DateTime?
  lockedUntil         DateTime?
  
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  lastLogin DateTime?
  
  // Relations
  createdIncidents Incident[]       @relation("CreatedBy")
  verifiedIncidents Incident[]      @relation("VerifiedBy")
  resolvedIncidents Incident[]      @relation("ResolvedBy")  // NEW
  photoUploads     IncidentPhoto[]  @relation("PhotoUploadedBy")
  incidentUpdates  IncidentUpdate[] @relation("UpdateCreatedBy")
  timelineEntries  IncidentTimeline[]  // NEW
  confirmedResolutions IncidentResolution[] @relation("ResolutionConfirmedBy")
  auditLogs        AuditLog[]
  refreshTokens    RefreshToken[]
  passwordResetTokens PasswordResetToken[]
  apiKeys          ApiKey[]
  passwordChanges  PasswordChange[]
  loginAttempts    LoginAttempt[]
  
  @@map("users")
}

model PasswordResetToken {
  id        String   @id @default(cuid())
  token     String   @unique
  userId    String
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  expiresAt DateTime
  used      Boolean  @default(false)
  createdAt DateTime @default(now())
  
  @@map("password_reset_tokens")
}

model RefreshToken {
  id        String   @id @default(cuid())
  tokenId   String   @unique
  userId    String
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  isRevoked Boolean  @default(false)
  expiresAt DateTime
  createdAt DateTime @default(now())
  revokedAt DateTime?

  @@map("refresh_tokens")
}

// =====================================================
// API KEY MANAGEMENT
// =====================================================

model ApiKey {
  id          String   @id @default(cuid())
  name        String   // Human-readable name for the key
  keyHash     String   @unique // HMAC-SHA256 hash of the actual key
  keyPrefix   String   // First 8 characters for quick identification
  userId      String   // Associated user (for admin keys)
  permissions Json     // Array of permissions: ["read", "write", "admin"]
  isActive    Boolean  @default(true)
  expiresAt   DateTime // Key expiration date
  lastUsedAt  DateTime?
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  
  // Relations
  user        User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  usageLogs   ApiKeyUsage[]

  @@map("api_keys")
}

model ApiKeyUsage {
  id        String   @id @default(cuid())
  apiKeyId  String
  endpoint  String   // API endpoint accessed
  method    String   // HTTP method
  ipAddress String
  userAgent String?
  timestamp DateTime @default(now())
  
  // Relations
  apiKey    ApiKey   @relation(fields: [apiKeyId], references: [id], onDelete: Cascade)

  @@map("api_key_usage")
}

// =====================================================
// PASSWORD SECURITY
// =====================================================

model PasswordChange {
  id             String   @id @default(cuid())
  userId         String
  oldPasswordHash String  // Hash of the old password for history checking
  changedAt      DateTime @default(now())
  changedBy      String   // IP address or user agent info
  
  // Relations
  user           User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@map("password_changes")
}

// =====================================================
// PERSONNEL MANAGEMENT
// =====================================================

model Personnel {
  id           String          @id @default(cuid())
  employeeId   String          @unique
  email        String          @unique
  password     String
  firstName    String
  lastName     String
  phone        String
  role         PersonnelRole
  status       PersonnelStatus @default(AVAILABLE)
  
  // Profile
  photo        String?
  dateOfBirth  DateTime?
  bloodType    String?
  address      String?
  emergencyContact String?
  
  // Status tracking
  isAvailable  Boolean         @default(true)
  currentDuty  String?
  
  createdAt    DateTime        @default(now())
  updatedAt    DateTime        @updatedAt
  lastActive   DateTime?
  
  // Relations
  locations      PersonnelLocation[]
  assignments    IncidentAssignment[]
  incidentUpdates IncidentUpdate[]
  notificationAcks IncidentNotificationAck[]
  primaryIncidents Incident[]         @relation("PrimaryResponder")  // NEW
  incidentResponders IncidentResponder[]  // NEW
  timelineEntries  IncidentTimeline[]  // NEW
  submittedResolutions IncidentResolution[] @relation("ResolutionSubmittedBy")
  passwordResetTokens PersonnelPasswordResetToken[]
  
  @@map("personnel")
}

model PersonnelPasswordResetToken {
  id          String    @id @default(cuid())
  token       String    @unique
  personnelId String
  personnel   Personnel @relation(fields: [personnelId], references: [id], onDelete: Cascade)
  expiresAt   DateTime
  used        Boolean   @default(false)
  createdAt   DateTime  @default(now())
  
  @@map("personnel_password_reset_tokens")
}

// =====================================================
// BARANGAY / POST MANAGEMENT
// =====================================================

model Barangay {
  id          String   @id @default(cuid())
  name        String   @unique
  code        String   @unique
  description String?
  
  // Location
  latitude    Float
  longitude   Float
  address     String
  coverageArea Json?  // GeoJSON polygon for coverage area
  
  // Contact (Legacy - kept for backward compatibility)
  contactPerson String?
  contactPhone  String?
  contactEmail  String?
  
  // Emergency Information
  operatingHours String?
  landmarks      String?
  
  isActive    Boolean  @default(true)
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  
  // Relations
  incidents          Incident[]
  emergencyContacts  EmergencyContact[]
  
  @@map("barangays")
}

model EmergencyContact {
  id          String               @id @default(cuid())
  barangayId  String
  name        String
  phone       String
  type        EmergencyContactType
  isPrimary   Boolean              @default(false)
  
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  
  // Relations
  barangay    Barangay @relation(fields: [barangayId], references: [id], onDelete: Cascade)
  
  @@map("emergency_contacts")
}

// =====================================================
// INCIDENT MANAGEMENT
// =====================================================

model Incident {
  id            String           @id @default(cuid())
  incidentNumber String          @unique
  
  // Incident Details
  type          IncidentType
  priority      IncidentPriority @default(MEDIUM)
  status        IncidentStatus   @default(REPORTED)
  title         String
  description   String
  
  // Location
  latitude      Float
  longitude     Float
  address       String
  landmark      String?
  
  // Reporter Information
  reporterName  String
  reporterPhone String
  reporterEmail String?
  
  // Timestamps
  reportedAt    DateTime         @default(now())
  acknowledgedAt DateTime?
  dispatchedAt  DateTime?
  resolvedAt    DateTime?
  closedAt      DateTime?
  
  // Metadata
  estimatedArrival DateTime?
  actualArrival    DateTime?
  responseTime     Int?          // in minutes
  
  createdAt     DateTime         @default(now())
  updatedAt     DateTime         @updatedAt
  
  // Public Report Fields
  isPublicReport   Boolean       @default(false)
  publicSessionId  String?
  verifiedAt       DateTime?
  verifiedById     String?
  
  // NEW: Workflow Fields (Multi-Personnel Support)
  primaryResponderId String?
  respondingAt       DateTime?
  resolutionNotes    String?
  resolvedById       String?
  
  // Relations
  createdBy     User?            @relation("CreatedBy", fields: [createdById], references: [id])
  createdById   String?
  
  verifiedBy    User?            @relation("VerifiedBy", fields: [verifiedById], references: [id])
  
  resolvedBy    User?            @relation("ResolvedBy", fields: [resolvedById], references: [id])
  
  primaryResponder Personnel?    @relation("PrimaryResponder", fields: [primaryResponderId], references: [id])
  
  barangay      Barangay?        @relation(fields: [barangayId], references: [id])
  barangayId    String?
  
  publicSession PublicSession?   @relation(fields: [publicSessionId], references: [id])
  
  assignments   IncidentAssignment[]
  updates       IncidentUpdate[]
  photos        IncidentPhoto[]
  notificationAcks IncidentNotificationAck[]
  responders    IncidentResponder[]  // NEW: Multi-personnel support
  timeline      IncidentTimeline[]   // NEW: Status timeline
  resolution    IncidentResolution?  // NEW: 5W1H resolution report
  
  @@map("incidents")
  @@index([status])
  @@index([priority])
  @@index([reportedAt])
  @@index([barangayId])
}

// =====================================================
// INCIDENT PHOTOS
// =====================================================

model IncidentPhoto {
  id          String   @id @default(cuid())
  url         String
  filepath    String   // Server file path
  filename    String
  mimeType    String
  size        Int
  caption     String?
  
  uploadedAt  DateTime @default(now())
  
  // Relations
  incident    Incident @relation(fields: [incidentId], references: [id], onDelete: Cascade)
  incidentId  String
  
  uploadedBy  User?    @relation("PhotoUploadedBy", fields: [uploadedById], references: [id])
  uploadedById String?
  
  @@map("incident_photos")
  @@index([incidentId])
  @@index([uploadedById])
}

// =====================================================
// INCIDENT ASSIGNMENTS
// =====================================================

model IncidentAssignment {
  id         String    @id @default(cuid())
  
  assignedAt DateTime  @default(now())
  arrivedAt  DateTime?
  completedAt DateTime?
  
  notes      String?
  
  // Relations
  incident   Incident  @relation(fields: [incidentId], references: [id], onDelete: Cascade)
  incidentId String
  
  personnel  Personnel @relation(fields: [personnelId], references: [id], onDelete: Cascade)
  personnelId String
  
  @@unique([incidentId, personnelId])
  @@map("incident_assignments")
  @@index([incidentId])
  @@index([personnelId])
}

// =====================================================
// INCIDENT UPDATES / ACTIVITY LOG
// =====================================================

model IncidentUpdate {
  id          String   @id @default(cuid())
  message     String
  updateType  String   // STATUS_CHANGE, COMMENT, ASSIGNMENT, etc.
  metadata    Json?    // Additional data (old status, new status, etc.)
  
  createdAt   DateTime @default(now())
  
  // Relations
  incident    Incident   @relation(fields: [incidentId], references: [id], onDelete: Cascade)
  incidentId  String
  
  user        User?      @relation("UpdateCreatedBy", fields: [userId], references: [id])
  userId      String?
  
  personnel   Personnel? @relation(fields: [personnelId], references: [id])
  personnelId String?
  
  @@map("incident_updates")
  @@index([incidentId])
  @@index([userId])
  @@index([createdAt])
}

// =====================================================
// INCIDENT NOTIFICATION ACKNOWLEDGMENTS
// =====================================================

model IncidentNotificationAck {
  id          String   @id @default(cuid())
  
  acknowledgedAt DateTime @default(now())
  
  // Relations
  incident    Incident   @relation(fields: [incidentId], references: [id], onDelete: Cascade)
  incidentId  String
  
  personnel   Personnel  @relation(fields: [personnelId], references: [id], onDelete: Cascade)
  personnelId String
  
  @@unique([incidentId, personnelId])
  @@map("incident_notification_acks")
  @@index([incidentId])
  @@index([personnelId])
  @@index([acknowledgedAt])
}

// =====================================================
// PERSONNEL LOCATION TRACKING
// =====================================================

model PersonnelLocation {
  id         String   @id @default(cuid())
  
  latitude   Float
  longitude  Float
  accuracy   Float?   // in meters
  altitude   Float?
  speed      Float?   // in m/s
  heading    Float?   // in degrees
  
  timestamp  DateTime @default(now())
  
  // Relations
  personnel  Personnel @relation(fields: [personnelId], references: [id], onDelete: Cascade)
  personnelId String
  
  @@map("personnel_locations")
  @@index([personnelId, timestamp])
}

// =====================================================
// AUDIT LOG
// =====================================================

model AuditLog {
  id           String   @id @default(cuid())
  
  action       String   // CREATE, UPDATE, DELETE, LOGIN, etc.
  resourceType String   // USER, PERSONNEL, INCIDENT, etc.
  resourceId   String?
  
  details      Json?    // Additional context data
  ipAddress    String?
  userAgent    String?
  
  timestamp    DateTime @default(now())
  
  // Relations
  user         User?    @relation(fields: [userId], references: [id])
  userId       String?
  
  @@map("audit_logs")
  @@index([userId])
  @@index([timestamp])
  @@index([resourceType, resourceId])
}

// =====================================================
// PUBLIC SESSION TRACKING
// =====================================================

model PublicSession {
  id           String   @id @default(cuid())
  sessionToken String   @unique @default(cuid())
  ipAddress    String?
  userAgent    String?
  
  // Rate limiting
  reportCount  Int      @default(0)
  lastReportAt DateTime?
  
  // Fraud detection
  isFlagged    Boolean  @default(false)
  flagReason   String?
  
  createdAt    DateTime @default(now())
  expiresAt    DateTime
  
  // Relations
  incidents    Incident[]
  
  @@map("public_sessions")
  @@index([sessionToken])
  @@index([ipAddress])
  @@index([expiresAt])
}

// =====================================================
// INCIDENT RESPONDERS (Multi-Personnel Support)
// =====================================================

model IncidentResponder {
  id          String    @id @default(cuid())
  incidentId  String
  personnelId String
  
  // Timestamps
  acceptedAt  DateTime  @default(now())
  arrivedAt   DateTime?
  leftAt      DateTime?
  
  // Role tracking
  isPrimary   Boolean   @default(false)
  
  // Additional context
  notes       String?
  
  // Relations
  incident    Incident  @relation(fields: [incidentId], references: [id], onDelete: Cascade)
  personnel   Personnel @relation(fields: [personnelId], references: [id], onDelete: Cascade)
  
  @@unique([incidentId, personnelId])
  @@map("incident_responders")
  @@index([incidentId])
  @@index([personnelId])
}

// =====================================================
// INCIDENT TIMELINE (Status History)
// =====================================================

model IncidentTimeline {
  id          String         @id @default(cuid())
  incidentId  String
  incident    Incident       @relation(fields: [incidentId], references: [id], onDelete: Cascade)
  
  // Status tracking
  status      IncidentStatus
  timestamp   DateTime       @default(now())
  
  // Actor tracking
  userId      String?
  user        User?          @relation(fields: [userId], references: [id])
  
  personnelId String?
  personnel   Personnel?     @relation(fields: [personnelId], references: [id])
  
  // Additional context
  notes       String?
  metadata    Json?
  
  @@map("incident_timeline")
  @@index([incidentId, timestamp])
}

// =====================================================
// INCIDENT RESOLUTION (5W1H Report)
// =====================================================

enum ResolutionOutcome {
  BROUGHT_TO_POLICE_STATION
  BROUGHT_TO_HOSPITAL
  RESPONDED_BY_FIREFIGHTER
  BROUGHT_TO_BARANGAY
  RESPONDED_BY_POLICE
  COMMON_RESOLVED
  OTHER
}

model IncidentResolution {
  id          String   @id @default(cuid())
  incidentId  String   @unique
  incident    Incident @relation(fields: [incidentId], references: [id], onDelete: Cascade)
  
  // 5W Fields
  what        String   // What happened
  when        String   // When did it happen
  where       String   // Where did it happen
  who         String   // Who was involved
  why         String   // Why did it happen
  how         ResolutionOutcome   // How was it resolved (outcome selection)
  
  // Additional notes
  notes       String?  // Additional notes
  
  // Personnel who submitted the resolution report
  submittedByPersonnelId  String
  submittedByPersonnel    Personnel @relation("ResolutionSubmittedBy", fields: [submittedByPersonnelId], references: [id])
  submittedAt             DateTime  @default(now())
  
  // Admin who confirmed the resolution
  confirmedByAdminId  String?
  confirmedByAdmin    User?      @relation("ResolutionConfirmedBy", fields: [confirmedByAdminId], references: [id])
  confirmedAt         DateTime?
  
  // Admin edits
  adminNotes     String?
  
  @@map("incident_resolutions")
}

model LoginAttempt {
  id          String   @id @default(cuid())
  userId      String?
  user        User?    @relation(fields: [userId], references: [id], onDelete: SetNull)
  email       String
  ipAddress   String
  userAgent   String?
  successful  Boolean
  attemptedAt DateTime @default(now())

  @@map("login_attempts")
}
